#!/usr/bin/env python3
import argparse
import os
import stat
import subprocess
import sys
import tempfile

def find_script_path(command_args):
    """Finds the path to the script in the command arguments."""
    for arg in command_args:
        if os.path.exists(arg) and not os.path.isdir(arg):
            # Simple check: if the arg is an existing file, assume it's the script.
            # This might not be perfect for all cases (e.g., `cat my_script.py | python3`).
            return arg
    return None

def read_file_content(path):
    """Reads the content of a file."""
    if not path:
        return "Could not find a script file to read."
    try:
        with open(path, 'r') as f:
            return f.read()
    except IOError as e:
        return f"Error reading file {path}: {e}"

def run_command(command_args):
    """Runs a command and captures its output."""
    return subprocess.run(command_args, capture_output=True, text=True)

def get_llm_fix(model, script_path, script_content, command_args, result, debug=False):
    """Constructs a prompt and gets a fix from the llm utility."""
    command_str = " ".join(command_args)
    prompt = f"""
I ran the following command:
`{command_str}`

The script file '{script_path}' has the following content:
```
{script_content}
```

The command failed with exit code: {result.returncode}

STDOUT:
```
{result.stdout}
```

STDERR:
```
{result.stderr}
```

Based on the script source, the command, and its output, provide a fixed version of the original script that will likely fix the problem.
Your response should contain *only* the raw source code for the fixed script, with no explanations, formatting, or markdown.
"""
    print(">>> Command failed. Asking LLM for a fix...")

    if debug:
        print("\n--- DEBUG: LLM INPUT ---")
        print(prompt.strip())
        print("--- END DEBUG INPUT ---\n")

    llm_command = ["llm"]
    if model:
        llm_command += ["-m", model]
    llm_command += [prompt.strip()]

    try:
        llm_result = subprocess.run(llm_command, capture_output=True, text=True, check=True)

        if debug:
            print("\n--- DEBUG: LLM RAW OUTPUT ---")
            print(llm_result.stdout)
            print("--- END DEBUG OUTPUT ---\n")

        # Sanitize the output to remove potential markdown code fences
        fix_script = llm_result.stdout.strip()
        if fix_script.startswith("```") and fix_script.endswith("```"):
            fix_script = "\n".join(fix_script.splitlines()[1:-1])
        return fix_script
    except (subprocess.CalledProcessError, FileNotFoundError) as e:
        print("Error calling LLM", file=sys.stderr)
        if isinstance(e, FileNotFoundError):
            print("Please ensure the 'llm' command-line tool is installed and in your PATH.", file=sys.stderr)
        sys.exit(1)


def run_fixed_script(fixed_script_content, command_args):
    """Runs the fixed script in a temporary file."""
    
    script_path = find_script_path(command_args)
    if not script_path:
        print("Could not find the original script path to create a temporary file.", file=sys.stderr)
        sys.exit(1)

    try:
        # Create a temporary file in the same directory as the original script
        # to handle relative imports correctly.
        script_dir = os.path.dirname(script_path)
        script_ext = os.path.splitext(script_path)[1]
        
        with tempfile.NamedTemporaryFile(mode='w+', delete=False, suffix=script_ext, dir=script_dir) as tmp:
            tmp.write(fixed_script_content)
            tmp.flush()
            tmp_path = tmp.name

        subprocess.run(['chmod', '+x', tmp_path], check=True)
        
        # Construct the new command to run the temporary script
        new_command_args = list(command_args)
        try:
            script_index = new_command_args.index(script_path)
            new_command_args[script_index] = tmp_path
        except ValueError:
            print(f"Could not find script path '{script_path}' in command arguments.", file=sys.stderr)
            sys.exit(1)

        print(f">>> LLM suggested a fix. Executing the fixed script from {tmp_path}...")
        print("-" * 20)
        
        # Use Popen to stream output in real-time
        with subprocess.Popen(new_command_args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True) as process:
            if process.stdout:
                for line in process.stdout:
                    print(line, end='')
            if process.stderr:
                for line in process.stderr:
                    print(line, end='', file=sys.stderr)
        
        print("-" * 20)
        print(">>> Fix execution finished.")

    finally:
        if 'tmp_path' in locals() and os.path.exists(tmp_path):
            os.remove(tmp_path)

def main():
    parser = argparse.ArgumentParser(
        description='A "smart wrapper" that uses an LLM to automatically fix a failed script.',
        epilog='From the saying: "if it fails, you should have used a bigger hammer".'
    )
    parser.add_argument(
        '-m', '--model',
        default=None,
        help='The model to use with the "llm" utility.'
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        help='Print the LLM input prompt and raw output for debugging.'
    )
    parser.add_argument(
        'command',
        nargs=argparse.REMAINDER,
        help='The command to execute and its arguments.'
    )
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
        
    print(f">>> Executing command: {" ".join(args.command)}")
    result = run_command(args.command)
    
    if result.returncode == 0:
        print(">>> Command executed successfully.")
        if result.stdout:
            print("\n--- STDOUT ---")
            print(result.stdout)
        if result.stderr:
            print("\n--- STDERR ---")
            print(result.stderr, file=sys.stderr)
        sys.exit(0)
    else:
        script_path = find_script_path(args.command)
        script_content = read_file_content(script_path)

        fix_script = get_llm_fix(args.model, script_path, script_content, args.command, result, args.debug)

        if fix_script:
            run_fixed_script(fix_script, args.command)
        else:
            print(">>> LLM did not provide a fix.", file=sys.stderr)
            sys.exit(result.returncode)

if __name__ == "__main__":
    main()
